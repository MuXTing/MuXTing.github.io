---
layout: post
title: "数的机器表示之一:关于整数原码和补码的讨论"
categories: 计算机组成原理
tags: 愚人的自救
date: 2019-09-15 15:28:00
comments: true
author: 孙光林
---

* content
{:toc}

## 序言
从大一开始也就知道了原码，补码这几个家伙。 现在大三，课堂正式教学， 老师也讲了， 教材也看了， 简单典型的例题也做了， 但是总是有那么一丝丝的“隔阂”， 心理上和思维上也总是有那么一点点的不舒畅， 所谓“幽咽流泉冰下难”的感觉。 笔者愚笨， 且懒， 知识底子也很浅， 但是也好个胡思乱想......




---
    注：本文非教学，而是讨论， 读者须自行了解相关概念。 



# 整数  

## 第一式: 真值与机器数。 

这些是最最基本的概念， 也是理解的基石， 务必要整明白， 理解。  
**参与计算机运算的数有两大类：无符号数和有符号数。无符号数简单明了，故而不讨论。 我们在此讨论的是*有符号数*。**  
真值就是我们平常写的， 一个+-号， （+号通常省略）再加上一个数字（随便什么进制）这就是真值了。 把+-符号进行*数字化*了以后，那个玩意叫做机器数。 也就是说：
>真值是没有**符号位**的。只有机器数有符号位的概念，即原码， 反码，补码， 移码这些—— ——机器数的最高位留出来用0/1来区分+/-。  

在我们学习或理解补码的时候， 我认为最好有以下的思维:  
> 1. **二进制思维**。摆脱掉我们日常生活中的十进制思维习惯。 时刻提醒自己， 这是在二进制计算中， 常驻在你的脑子里的不应该是4,5,6,7,8这些玩意儿。 而应该是一堆堆的01串。  
> 2. **为了表示和运算**。我们费劲整出来的这个码， 那个码的。 都是为了信息数据能在计算机中更好的*表示和运算*。 表示很简单， 那么一些设计的目的就是为了运算了。无论是为了更容易理解的运算，更简洁的运算， 更快的运算，还是别的啥的。 运算是最根本的需求。把符号数字化成01， 也就把真值转换成了机器数。 补码的设计就是为了让符号也能够直接参与运算。 
> 3. **符号与绝对值**。一个数可以分成两部分， 一部分是这个数的符号， 一部分是这个数的绝对值(可以用无符号数来带入)。 无论真值还是机器数。 我们都应该这样去想。 (只不过真值往往缺省+号)
> 4. **\"用零补位\"**。整数的位数n是不定的， 原码001是3位， 原码000000001是9位，它们的真值都是+1。(正数的符号往往默认省略)

 

## 第二式: Gimmick
    注：gimmick这个词是我从HARRY J.GENSLER的 《Introduction to Logic》一书中借用过来的。原文是在介绍一个关于Syllogistic Logic 的叫做star test 的 gimmick, :
        The star test is a gimmick, but a quick and effective one; for now it's   best just to learn the test and not worry about why it works.   
    从这句话我们可以看出，"a gimmick" 强调的是quick , effective, 以及not worry about why.
    这对于纯应用是很棒的，做题，考试之类的。 但是当我们学习的时候， 最好还是讲究一下"why"。这对我们的思维和思想有大大的好处。 

关于原码的gimmick:  
1. 求出真值的绝对值， 正数最左边补0， 负数最左边补1。  

关于补码的gimmick：  
1. 正数的补码形式就是原码的形式。 
2. 负数的补码等于其反码+1. 
3. 负数的补码可以这样求: 把它的原码字低位向高位看去。 遇到的第一个'1'及其右边的'0'都不变，将左边的所有位按位取反， 符号位不变。 这样就可得到负数的补码形式。
4. 当用N个bit来表示一个负数的时候， 这N个bit所能表示的最小的负数的补码形式就是-0的原码形式, 比如8bit所能表示的最小负数是-128, 它的补码就是10000000。
5. 当用N个bit来表示一个在可表示范围之内的负数的时候， 这个负数的补码形式可以由最小负数的补码形式(上一条gimmick)加上一个数来表示。 比如： 8bit的情况下， -127 = -128 + 1. 
所以-127的补码形式就可以通过 10000000 + 1 => 10000001得到。 

绝大多数的普通学生对于补码的认识就是这样，老师甚至也是这样交的，定义什么的不重要。 但是这些是概念的定义吗。 我们能通过这些gimmick快速的做题和应用， 但是我们能理解这些概念吗。 

## 第三式: Definition
考察了两本书的定义，本来想在《深入理解计算机系统》里面找找定义的， 结果没有。   
一本是薛胜军主编的《计算机组成原理(第三版)》  
一本是唐朔飞的《计算机组成原理(第二版)》  

唐版教材对原码的定义:
>约定整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开

>$$
[x]_{yuan}=\begin{cases}
0,x & 2^n > x { \geq } 0 \\
2^n - x & 0 {\geq} x > -2^n 
\end{cases}
$$

>式子中, x为真值, n为整数的位数。

(笔者注：[x]表示真值x的原码，原书中是[x]<sub>原</sub>的形式， markdown语法在公式中打不出来汉字下标，顾而用拼音代替)  
唐版教材对补码的定义：  
>$$
[x]_{bu}=\begin{cases}
0,x & 2^n > x { \geq } 0 \\
2^{n+1} + x & 0 > x {\geq} -2^n (mod2^{n+1})
\end{cases}
$$

> 式中， x为真值, n为整数的位数。  
例如：
当x = -1101时,  
$[x]_{bu}=2^{n+1}+x=100000-1011=1,0011$

薛版教材对原码的定义:    
> 纯整数时, 设x=x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>...x<sub>n-1</sub>,其中, x<sub>0</sub>为符号位, 共n位字长,则  

>$$
[x]_{yuan}=\begin{cases}
x & 2^{n-1}-1 {\geq} x { \geq } 0 \\
2^{n-1} - x=2^{n-1}+|x| & 0 {\geq} x {\geq} -(2^{n-1}-1)
\end{cases}
$$

薛版教材对补码的定义:   
> 纯整数时, 设x=x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>...x<sub>n-1</sub>, 共n位字长,则  

>$$
[x]_{bu}=\begin{cases}
x & 2^{n-1}-1 {\geq} x { \geq } 0 \\
2^{n} + x=2^{n} - |x| & 0 > x {\geq} -(2^{n-1})
\end{cases}
$$

>例如, $x_1=+1011,x_2=-1011$, 字长为8位， 则其补码为  
$$[x_1]_{bu}=00001011$$  
$$[x_2]_{bu}=2^8-0001011=100000000-0001011=11110101$$   

***(笔者按:再用公式算完之后,用gimmick验算一下，你会发现，真正应用的时候，的确gimmick效率高，速度快，所以我们既要理解概念又要掌握方法)***

我们比较一下二者的定义的区别。   
1. 先看对原码的定义:  
&emsp;&emsp;首先，式子中x表示什么， 唐版明确的说明了， x表示真值。 也就是说x写出来是带+-号的， 它的符号没有数字化。 但是薛版没有明确说x是什么， 但是他说$x_0$表示符号位，那也就是说x是经过符号化了的， 即x是机器数。   
&emsp;&emsp;其次， n表示什么， 唐版说明n是整数的位数， 不是很明确，因为我们不知道是*真值的绝对值*的位数还是*与真值对应的机器数*的位数？根据给出的例子(本文只打出了补码的例子,但是书中的概念是一致的)，可以判断出**n是真值的绝对值的位数**。 薛版中n的位数，直接说明是整数x的位数。 上文我们已经根据它的定义进行了判断， x是机器数, 也就是**n是与真值对应的机器数的位数**。 再根据例题推断, n也的确是与真值对应的机器数的位数。   
&emsp;&emsp;接下来，再看这个数学表达式。 对于正数的情况没什么好说的，唐版为了让我们在书写中更加的容易辨识符号位，使用了逗号将符号位与值分离的写法。这个看个人喜好了，无所谓。 看负数的表示，从形式上， 薛版的定义比唐版的定义多了一步， 多的这一步就是明确的体现了“符号数字化”这个过程
，也体现了一个数是由两个部分组成的：数的符号&&数的绝对值。 $2^{n-1}$就是符号位， |x|是数的绝对值。 $2^{n-1}+|x|$很好的体现了这一点， 而唐版就是跳步骤了， 直接呈现去绝对值符号之后的式子。  
&emsp;&emsp;再往下看， 范围。这个时候n代表什么意思，就很重要了。由于这个表示的是整数， 那么${\geq}$ 与 > 号的替换也就是一个加减1的问题，这个没什么。 从上标的n还是n-1我们就可以看出来， 唐版是指，当一个真值x的绝对值是用n位来表示的时候， 这n位整数，可表示的真值范围，再次注意啊， 真值是没有符号位的，+-号是另外加的。而薛版的是什么意思呢， 一个真值对应的原码x有n位，注意了，原码是机器码，它有符号位的， 也就是说n位里面有一位是符号位。 所以真正能来表示数的绝对值范围的只有n-1位， 那么，这n-1位可表示的最大的数就是 $2^{n-1}-1$  
&emsp;&emsp;最后，我们综合的看这两个原码定义。 可以发现，薛版的是有点混乱的。 
2. 再看补码的定义  
&emsp;&emsp;正整数没什么好说的。  
&emsp;&emsp;看负数的定义， 两版的x很n代表的意义同原码的定义一样，没什么好说的。 薛版的式子仍然是多出来一步， 对于多出来的这一步， 如果理解了补码的设计思想的话是很容易理解的。稍候请联系下文，进行理解。 再看范围， 负数的原，补码的表示范围有一点点的差别， 那就是没有负零了。 

我们来总的看一看这两版书的定义。 唐版有两点瑕疵:
1. 没有很明确的指出n到底是真值绝对值的位数还是与真值对应的机器数的位数。
2. 跳步骤了，使初学者不易理解公式的含义。  

而薛版却是有一点混乱——x到底是什么意思。
1. *"设x=x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>...x<sub>n-1</sub>,其中,x<sub>0</sub>为符号位."*从这句话推断出，x是机器数, 但是如果x已经是给出了的机器数的话，又何必再去求机器数呢。   
但是呢, [x]<sub>yuan</sub>(原书中为[x]<sub>原</sub>)这个形式又分明是说x代表真值,而[x]<sub>yuan</sub>才是代表真值的原码。   
如果把x当n位机器数来看, 范围的表示是与这个假设统一的，但是
如果你仔细看薛版的补码例子的时候,你会发现$x_2$在带入公式的时候，是用7位数字表示的， 而题目中给出的条件,字长为8位。 7位数字说明$x_2$是以真值的形式带入的且与它的定义也矛盾。结合它的定义和例子， x一会儿表示真值，一会儿表示真值的n位机器数。 很是矛盾。 

```c
/*为什么要比较这两个教材的定义呢， 一方面是这两本是国内教材的一个代表吧。 其他的应该大同小异，并且我校采用的是薛版的书。 另一方面，教材对初学者是很重要的。 初学者一无所知，所以很依赖以及信任教材，很遗憾，有些教材辜负了这种信任。 让初学者看的一言难尽，有的有错误， 有的不给你讲透，高高在上。毕竟大多数人都是普通人， 不是名校的高材生。 */
```

## 第四式：补码的设计思想
要提两个概念。 一个是模，一个是补数。 
可以去参考唐版的教程。我将在文章末尾贴上原文。 不多赘述，仅罗列几个结论和gimmick。   
1. 一个负数可用它的正补数来代替， 而这个正补数可以用模加上负数本身求得。 
2. 一个正数和一个负数互为补数时， 它们绝对值之和即为模数。
3. 正数的补数即该正数本身。 
4. 通常模就是计量器具的容量， 或称模数。
5. 如果某一数有n位整数(包括1位符号数)， 则它的模数为$2^n$； 如果是n位小数(包括一位符号位),则它的模数总是为2
6. 对于n位数来说,则它的模数M的大小是:n位数全为1后， 再在最末位加1.

(笔者按: 笔者本人对模的概念还是很模糊，唐版教材也只是打比方，举例子进行说明。 模到底是啥， 模怎么来的仍不是很清楚。而薛版教材只给了3条结论，就是上文的最后两条)  
指明一下: 如果一个真值的绝对值是用n位来表示的话。 那么它的模是比这个真值多两位的, 也就是说有n+2位。 注意是相对于真值的位数来说的， 一般来说，机器数比真值的绝对值是要多一位符号位的。 那么模数就比机器数对1位。 
## 第五式: 基于我个人理解的修正后的整数补码的定义。
原码的定义很简单。就不说了。
我比较喜欢唐版的逗号分隔，遂采用。 
> 设x为整数真值,  n为真值绝对值的位数。
>$$
[x]_{bu}=\begin{cases}
0,|x| & 2^n > x { \geq } 0 \\
2^{n+1} - |x|=2^{n+1} + x & 0 > x {\geq} -2^n (mod2^{n+1})
\end{cases}
$$

>注: n位真值的机器数位n+1位。也就是说, x是n位, $[x]_{bu}$是n+1位。 


## 第六式：-128的8bit补码表示的讨论。

我们先别管其他的， 根据公式来求出-128的补码。  
[-128]<sub>10</sub> = [-$2^7$]<sub>10</sub>=[-10000000]<sub>2</sub>
上式说明, -128的二进制形式真值最起码是8位。 根据我们的经验，它的补码应该是9位。  
带入公式, 可知，n = 8;  
$[x]_{bu}=2^{8+1} + (-10000000)=1000000000 - 10000000 = 110000000$
也就是说-128的补码是110000000, 9位数。 
众所周知， -128的补码有8位的形式， 就是10000000。 怎么来的呢， 最熟悉的解释是：把负0的8位原码，也就是10000000, 分给了-128。 这也是原码，补码定义中，表示范围不同的缘由, 补码没有负零与正零的区别，负零用来表示-128了。 那么换言之，就是-128的8位表示是人为规定的了。 因为根据公式，-128是不可能有8位的补码的。 
那么这两种解释，如何统一呢。 我的理解是:
机器把最高位给丢弃了。 因为倘若规定了用8位来表示一个补码，那么110000000 丢掉最高位就是10000000。 甚至，还可以这样去理解"反码+1"求补码的那个gimmick。这个理解也可以推广到n位补码的最小负数的表示上。  
***也就是说凡是2的倍数的整数，都有一个与它的最小真值位数相同位数的补码。***  
其实到这里，我们应该感觉到， 一个真值可以有"不同的"补码。 取决于机器规定用几个bit来表示补码。 (在可表示范围之内。) 
比如说: 
> 
    -2的补码。   
    -5的二进制位-101.   
    最起码要用3位表示。  
    那么， 补码为:1011.  
    如果真值的位数为4: -0101  
    那么， 补码为:11011  
    如果真值的位数为5: -00101  
    那么， 补码为:111011 
    从而我们也就可以如法得出我们想要的位数的补码了。 (在可表示范围之内)
    以上结果无论是用定义还是gimmick都可得到。  
    
## 第七式: 一切为了运算
原码是表示起来最简单，明了的机器码，但是之后又设计了反码，补码， 移码。现在的计算机中通常采用补码或者移码来表示数。   
那为什么不用原码，反码呢，既然都能表示数，原码还是最简单明了的，那么只有一个解释，它在运算上有缺陷！大家可以用几个正负数加加减减来操作一波。 更加详细的我就不赘述了。大家可以参考这篇博文：
<a href="https://www.jianshu.com/p/3d92fe1c34af" _blank:target>补码杂谈</a>

## 打完收工
资料:  
![Image Text](https://raw.githubusercontent.com/MuXTing/MuXTing.github.io/master/pic/关于补数和模/1.jpg) 
![Image Text](https://raw.githubusercontent.com/MuXTing/MuXTing.github.io/master/pic/关于补数和模/2.jpg) 
## 后记
本文必定有漏洞，谬误，理解不周，理解错误的地方。 请您指点:
3030396529@qq.com  
参考资料:  
《计算机组成原理》唐朔飞第二版  
《计算机组成原理》薛胜军第三版  
《深入理解计算机系统》第三版