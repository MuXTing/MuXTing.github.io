---
<script type="text/javascript"
       src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
layout: post
title: " 数的机器表示之一:关于原码和补码的讨论"
categories: 计算机组成原理
tags: 愚人的自救
date: 2019-09-15 15:28:00
comments: true
author: 孙光林
---

* content
{:toc}

## 序言
从大一开始也就知道了原码，补码这几个家伙。 现在大三，课堂正式教学， 老师也讲了， 教材也看了， 简单典型的例题也做了， 但是总是有那么一丝丝的“隔阂”， 心理上和思维上也总是有那么一点点的不舒畅， 所谓“幽咽流泉冰下难”的感觉。 笔者愚笨， 且懒， 知识底子也很浅， 但是也好个胡思乱想......




---
    注：本文非教学，而是讨论， 读者须自行了解相关概念。 
# 整数  

## 第一式: 真值与机器数。 

这些是最最基本的概念， 也是理解的基石， 务必要整明白， 理解。  
**参与计算机运算的数有两大类：无符号数和有符号数。无符号数简单明了， 故而不讨论。 我们在此讨论的是*有符号数*。**  
真值就是我们平常写的， 一个+-号， （+号通常省略）再加上一个数字（随便什么进制）这就是真值了。 把+-符号进行*符号化*了以后，那个玩意叫做机器数。 也就是说：
>真值是没有符号位的， 只有机器数有符号位的概念，也就是原码， 反码，补码， 移码这些—— ——最高位留出来用0/1来区分+和-。  

在我们学习，理解这个知识点的时候， 我认为最好有以下的思维:  
> 1. 二进制思维。摆脱掉我们日常生活中的十进制思维习惯。 时刻提醒自己， 这是在二进制计算中， 常驻在你的脑子里的不应该是4,5,6,7,8这些玩意儿。 而应该是一堆堆的01串。  
> 2. 我们费这个劲整出来的这个码， 那个码的。 都是为了信息数据能在计算机中更好的*表示和运算*。 表示很简单， 那么一些设计的目的就是为了运算了。无论是为了更容易理解的运算，更简洁的运算， 更快的运算，还是别的啥的。 运算是最根本的需求。 
> 3. 一个数可以分成两部分， 一部分是这个数的符号， 一部分是这个数的绝对值(可以用无符号数来带入)。 无论真值还是机器数。 我们都应该这样去想。 (只不过真值往往缺省+号)

那么把符号数字化成01， 把真值转换成机器数。 设计各种码， 反码， 补码什么的， 就是为了让符号也能够直接参与运算。 

## 第二式: gimmick
    注：gimmick这个词是我从HARRY J.GENSLER的 《Introduction to Logic》一书中借用过来的。原文是在介绍一个关于Syllogistic Logic 的叫做star test 的 gimmick, :
        The star test is a gimmick, but a quick and effective one; for now it's   best just to learn the test and not worry about why it works.   
    从这句话我们可以看出，a gimmick 强调的是quick , effective, 以及not worry about why.
    这对于纯应用是很棒的，做题，考试之类的。 但是当我们学习的时候， 最好还是讲究一下"why"。

关于原码的gimmick:  
1. 求出真值的绝对值， 正数最左边补0， 负数最左边补1。  

关于补码的gimmick：  
1. 正数的补码形式就是原码的形式。 
2. 负数的补码等于其反码+1. 
3. 负数的补码可以这样求: 把它的原码字低位向高位看去。 遇到的第一个'1'及其右边的'0'都不变，将左边的所有位按位取反， 符号位不变。 这样就可得到负数的补码形式。
4. 当用N个bit来表示一个负数的时候， 这N个bit所能表示的最小的负数的补码形式就是-0的原码形式, 比如8bit所能表示的最小负数是-128, 它的补码就是10000000。
5. 当用N个bit来表示一个在可表示范围之内的负数的时候， 这个负数的补码形式可以由最小负数的补码形式(上一条gimmick)加上一个数来表示。 比如： 8bit的情况下， -127 = -128 + 1. 
所以-127的补码形式就可以通过 10000000 + 1 => 10000001得到。 

绝大多数的普通学生对于补码的认识就是这样，老师甚至也是这样交的，定义什么的不重要。 但是这些是概念的定义吗。 我们能通过这些gimmick快速的做题和应用， 但是我们能理解这些概念吗。 

## 第三式: Definition
考察了两本书的定义，本来想在《深入理解计算机系统》里面找找定义的， 结果没有。   
一本是薛胜军主编的《计算机组成原理(第三版)》  
一本是唐朔飞的《计算机组成原理(第二版)》  

唐版教材对原码的定义:  
>$$
[x]_{yuan}=\begin{cases}
0,x & 2^n > x { \geq } 0 \\
2^n - x & 0 {\geq} x > -2^n 
\end{cases}
$$
>式子中, x为真值, n为整数的位数。

(笔者注：[x]表示真值x的原码，原书中是[x]<sub>原的形式， markdown语法打不出来汉字下标，顾而用拼音代替)  
唐版教材对补码的定义：
>$$
[x]_{bu}=\begin{cases}
0,x & 2^n > x { \geq } 0 \\
2^n - x & 0 > x {\geq} -2^n (mod2^{n+1})
\end{cases}
$$

薛版教材对原码的定义:  
薛版教材对补码的定义:   





